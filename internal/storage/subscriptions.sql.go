// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package storage

import (
	"context"

	enums "github.com/serjnester/weather-subscription-service/domain/enums"
)

const confirmSubscription = `-- name: ConfirmSubscription :exec
UPDATE subscriptions
SET confirmed = true
WHERE token = $1
`

func (q *Queries) ConfirmSubscription(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, confirmSubscription, token)
	return err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (email, city, frequency, token)
VALUES ($1, $2, $3, $4)
    RETURNING id, email, city, frequency, confirmed, token, created_at
`

type CreateSubscriptionParams struct {
	Email     string
	City      string
	Frequency enums.Frequency
	Token     string
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.Email,
		arg.City,
		arg.Frequency,
		arg.Token,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.City,
		&i.Frequency,
		&i.Confirmed,
		&i.Token,
		&i.CreatedAt,
	)
	return i, err
}

const getSubscriptionByToken = `-- name: GetSubscriptionByToken :one
SELECT id, email, city, frequency, confirmed, token, created_at FROM subscriptions
WHERE token = $1
`

func (q *Queries) GetSubscriptionByToken(ctx context.Context, token string) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByToken, token)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.City,
		&i.Frequency,
		&i.Confirmed,
		&i.Token,
		&i.CreatedAt,
	)
	return i, err
}

const isAlreadySubscribed = `-- name: IsAlreadySubscribed :one
SELECT COUNT(*) FROM subscriptions
WHERE email = $1 AND city = $2
`

type IsAlreadySubscribedParams struct {
	Email string
	City  string
}

func (q *Queries) IsAlreadySubscribed(ctx context.Context, arg IsAlreadySubscribedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isAlreadySubscribed, arg.Email, arg.City)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const unsubscribe = `-- name: Unsubscribe :exec
DELETE FROM subscriptions
WHERE token = $1
`

func (q *Queries) Unsubscribe(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, unsubscribe, token)
	return err
}
